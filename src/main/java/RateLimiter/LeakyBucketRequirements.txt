ğŸ”¹ Functional Requirements
1ï¸âƒ£ Fixed Processing Rate
    Requests are processed at a constant rate (e.g., 1 request per 100ms).
    Excess requests wait in a queue instead of being dropped immediately.

2ï¸âƒ£ Queue for Bursty Traffic
    Requests exceeding the rate limit are queued in a fixed-size buffer (bucket).
    If the queue is full, new requests are dropped.

3ï¸âƒ£ Thread-Safe Implementation
    Multiple threads should be able to call allowRequest().
    Concurrent access should be handled using thread-safe data structures.

4ï¸âƒ£ Processing in the Background
    A scheduled task or background thread should continuously process requests at a fixed interval.
    Requests should leak out at a steady rate.

ğŸ”¹ Non-Functional Requirements
âœ… Low Latency â€“ Must handle high QPS efficiently.
âœ… Scalability â€“ Should support multiple rate limits per user/service.
âœ… Fairness â€“ Prevents a burst of requests from starving other users.
âœ… Extensibility â€“ Should be easy to adapt for distributed rate limiting (e.g., Redis-based).

ğŸ”¹ Example Scenarios
ğŸ“Œ API Rate Limiting â€“ Ensures API servers are not overwhelmed.
ğŸ“Œ Traffic Shaping â€“ Controls bursty traffic in networking applications.
ğŸ“Œ Database Protection â€“ Prevents sudden high loads from overloading a DB.